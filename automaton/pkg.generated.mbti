// Generated using `moon info`, DON'T EDIT IT
package "illusory0x0/automaton"

import(
  "illusory0x0/graphviz"
  "moonbitlang/core/set"
)

// Values
const EpsilonChar : Char = 'Îµ'

const ToplevelInitialState : Int = 0

// Errors

// Types and methods
pub struct DFA {
  initial : DFAS
  finals : DFASS
  transition : DFAT
  alphabet_count : Int
}
fn DFA::alphabet(Self) -> Iter[Symbol]
fn DFA::dead_state(Self) -> DFAS
fn DFA::minimize(Self) -> Self
fn DFA::partition(Self) -> @set.Set[DFASS]
fn DFA::reverse_transition(Self) -> FixedArray[FixedArray[DFASS]]
fn DFA::to_digraph(Self, label_to_letter~ : (Label) -> Char) -> @graphviz.Digraph

type DFAS
fn DFAS::from(Int) -> Self
fn DFAS::to_int(Self) -> Int
impl Eq for DFAS
impl Hash for DFAS
impl Show for DFAS
impl ToJson for DFAS

type DFASS
fn DFASS::add(Self, DFAS) -> Unit
fn DFASS::contains(Self, DFAS) -> Bool
fn DFASS::empty() -> Self
fn DFASS::is_empty(Self) -> Bool
fn DFASS::iter(Self) -> Iter[DFAS]
fn DFASS::length(Self) -> Int
fn DFASS::singleton(DFAS) -> Self
impl BitAnd for DFASS
impl Eq for DFASS
impl Hash for DFASS
impl Show for DFASS
impl Sub for DFASS

type DFAT
fn DFAT::iter2(Self) -> Iter2[DFAS, FixedArray[DFAS]]
fn DFAT::length(Self) -> Int
fn DFAT::op_get(Self, DFAS) -> FixedArray[DFAS]
fn DFAT::op_set(Self, DFAS, FixedArray[DFAS]) -> Unit
fn DFAT::set_trans(Self, DFAS, Symbol, DFAS) -> Unit
fn DFAT::trans(Self, DFAS, Symbol) -> DFAS
impl Eq for DFAT
impl Show for DFAT
impl ToJson for DFAT

pub(all) enum Label {
  Symbol(Symbol)
  Epsilon
}
impl Compare for Label
impl Eq for Label
impl Hash for Label
impl Show for Label
impl ToJson for Label

pub(all) struct NFA {
  initial : NFAS
  final_ : NFAS
  alphabet_count : Int
  transition : NFAT
}
fn NFA::alphabet(Self) -> Iter[Symbol]
fn NFA::epsilon_closure(Self, NFASS) -> NFASS
fn NFA::move_(Self, NFASS, Symbol) -> NFASS
fn NFA::powerset_construction(Self) -> RDFA
fn NFA::to_digraph(Self, label_to_letter~ : (Label) -> Char) -> @graphviz.Digraph
impl Eq for NFA
impl Show for NFA
impl ToJson for NFA

pub struct NFAC {
  nfa : RNFA
  count : Int
}

type NFAS
fn NFAS::from(Int) -> Self
fn NFAS::to_int(Self) -> Int
impl Compare for NFAS
impl Eq for NFAS
impl Hash for NFAS
impl Show for NFAS
impl ToJson for NFAS

type NFASS
fn NFASS::add(Self, NFAS) -> Unit
fn NFASS::contains(Self, NFAS) -> Bool
fn NFASS::copy(Self) -> Self
fn NFASS::empty() -> Self
fn NFASS::is_empty(Self) -> Bool
fn NFASS::iter(Self) -> Iter[NFAS]
fn NFASS::singleton(NFAS) -> Self
fn NFASS::to_array(Self) -> Array[NFAS]
fn NFASS::update_with_add(Self, NFAS) -> Self
impl Eq for NFASS
impl Hash for NFASS
impl Show for NFASS
impl ToJson for NFASS

type NFAT
fn NFAT::get(Self, NFAS) -> Map[Label, NFASS]?
fn NFAT::iter(Self) -> Iter[Map[Label, NFASS]]
fn NFAT::iter2(Self) -> Iter2[NFAS, Map[Label, NFASS]]
fn NFAT::length(Self) -> Int
fn NFAT::op_get(Self, NFAS) -> Map[Label, NFASS]
fn NFAT::op_set(Self, NFAS, Map[Label, NFASS]) -> Unit
fn NFAT::to_digraph(Self, label_to_letter~ : (Label) -> Char) -> @graphviz.Digraph
impl Eq for NFAT
impl Show for NFAT
impl ToJson for NFAT

pub struct RDFA {
  initial : NFASS
  finals : @set.Set[NFASS]
  transition : RDFAT
  alphabet_count : Int
}
fn RDFA::count(Self) -> Int
fn RDFA::states(Self) -> Iter[NFASS]
fn RDFA::to_dfa(Self) -> DFA
fn RDFA::to_digraph(Self, label_to_letter~ : (Label) -> Char) -> @graphviz.Digraph
impl Show for RDFA
impl ToJson for RDFA

type RDFAT
fn RDFAT::contains(Self, NFASS) -> Bool
fn RDFAT::iter2(Self) -> Iter2[NFASS, Map[Symbol, NFASS]]
fn RDFAT::length(Self) -> Int
fn RDFAT::op_get(Self, NFASS) -> Map[Symbol, NFASS]
fn RDFAT::op_set(Self, NFASS, Map[Symbol, NFASS]) -> Unit
fn RDFAT::states(Self) -> Iter[NFASS]
fn RDFAT::update(Self, NFASS, (Map[Symbol, NFASS]?) -> Map[Symbol, NFASS]?) -> Unit
impl Eq for RDFAT
impl Show for RDFAT
impl ToJson for RDFAT

pub(all) enum RNFA {
  Symbol(initial~ : NFAS, Label, final_~ : NFAS)
  Concat(RNFA, RNFA)
  Choice(initial~ : NFAS, RNFA, RNFA, final_~ : NFAS)
  Repeat(initial~ : NFAS, RNFA, final_~ : NFAS)
}
fn RNFA::to_digraph(Self, label_to_letter~ : (Label) -> Char) -> @graphviz.Digraph
impl Compare for RNFA
impl Eq for RNFA
impl Show for RNFA
impl ToJson for RNFA

pub(all) enum Regex {
  Concat(Regex, Regex)
  Choice(Regex, Regex)
  Repeat(Regex)
  Symbol(Label)
}
fn Regex::thompson_construction(Self, initial~ : Int, alphabet_count~ : Int) -> NFA
fn Regex::to_nfac(Self, initial~ : Int) -> NFAC
impl Compare for Regex
impl Eq for Regex
impl Show for Regex
impl ToJson for Regex

type Symbol
fn Symbol::from(Int) -> Self
fn Symbol::to_int(Self) -> Int
impl Compare for Symbol
impl Eq for Symbol
impl Hash for Symbol
impl Show for Symbol
impl ToJson for Symbol

// Type aliases

// Traits

