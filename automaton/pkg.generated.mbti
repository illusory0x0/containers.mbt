// Generated using `moon info`, DON'T EDIT IT
package "illusory0x0/automaton"

import(
  "illusory0x0/graphviz"
  "moonbitlang/core/set"
)

// Values
const Epsilon : Char = 'Îµ'

const EpsilonSymbol : Int = 0

const ToplevelInitialState : Int = 0

// Errors

// Types and methods
pub struct DFA {
  initial : Int
  finals : @set.Set[Int]
  edfat : FixedArray[FixedArray[Int]]
}
fn DFA::dead_state(Self) -> Int
fn DFA::minimize(Self, Int) -> Self
fn DFA::partition(Self, Int) -> @set.Set[DFAS]
fn DFA::reverse_transition(Self, Int) -> FixedArray[FixedArray[@set.Set[Int]]]
fn DFA::to_digraph(Self, symbol_to_letter~ : (Int) -> Char) -> @graphviz.Digraph

type DFAS
fn DFAS::contains(Self, Int) -> Bool
fn DFAS::equal(Self, Self) -> Bool // from trait `Eq`
fn DFAS::hash(Self) -> Int // from trait `Hash`
fn DFAS::hash_combine(Self, Hasher) -> Unit // from trait `Hash`
fn DFAS::is_empty(Self) -> Bool
fn DFAS::iter(Self) -> Iter[Int]
fn DFAS::land(Self, Self) -> Self // from trait `BitAnd`
fn DFAS::length(Self) -> Int
#deprecated
fn DFAS::op_equal(Self, Self) -> Bool // from trait `Eq`
#deprecated
fn DFAS::op_sub(Self, Self) -> Self // from trait `Sub`
fn DFAS::output(Self, &Logger) -> Unit // from trait `Show`
fn DFAS::sub(Self, Self) -> Self // from trait `Sub`
fn DFAS::to_string(Self) -> String // from trait `Show`
impl BitAnd for DFAS
impl Eq for DFAS
impl Hash for DFAS
impl Show for DFAS
impl Sub for DFAS

pub(all) struct NFA {
  initial : Int
  final_ : Int
  alphabet_count : Int
  nfat : NFAT
}
fn NFA::equal(Self, Self) -> Bool // from trait `Eq`
#deprecated
fn NFA::op_equal(Self, Self) -> Bool // from trait `Eq`
fn NFA::output(Self, &Logger) -> Unit // from trait `Show`
fn NFA::powerset_construction(Self) -> RDFA
fn NFA::to_digraph(Self, symbol_to_letter~ : (Int) -> Char) -> @graphviz.Digraph
fn NFA::to_json(Self) -> Json // from trait `ToJson`
fn NFA::to_string(Self) -> String // from trait `Show`
impl Eq for NFA
impl Show for NFA
impl ToJson for NFA

pub struct NFAC {
  nfa : RNFA
  count : Int
}

type NFAS
fn NFAS::equal(Self, Self) -> Bool // from trait `Eq`
fn NFAS::hash(Self) -> Int // from trait `Hash`
fn NFAS::hash_combine(Self, Hasher) -> Unit // from trait `Hash`
fn NFAS::is_empty(Self) -> Bool
fn NFAS::iter(Self) -> Iter[Int]
#deprecated
fn NFAS::op_equal(Self, Self) -> Bool // from trait `Eq`
fn NFAS::output(Self, &Logger) -> Unit // from trait `Show`
fn NFAS::to_json(Self) -> Json // from trait `ToJson`
fn NFAS::to_string(Self) -> String // from trait `Show`
impl Eq for NFAS
impl Hash for NFAS
impl Show for NFAS
impl ToJson for NFAS

type NFAT
fn NFAT::equal(Self, Self) -> Bool // from trait `Eq`
fn NFAT::get(Self, Int) -> Map[Int, @set.Set[Int]]?
fn NFAT::iter(Self) -> Iter[Map[Int, @set.Set[Int]]]
fn NFAT::iter2(Self) -> Iter2[Int, Map[Int, @set.Set[Int]]]
fn NFAT::length(Self) -> Int
#deprecated
fn NFAT::op_equal(Self, Self) -> Bool // from trait `Eq`
fn NFAT::op_get(Self, Int) -> Map[Int, @set.Set[Int]]
fn NFAT::op_set(Self, Int, Map[Int, @set.Set[Int]]) -> Unit
fn NFAT::output(Self, &Logger) -> Unit // from trait `Show`
fn NFAT::to_digraph(Self, symbol_to_letter~ : (Int) -> Char) -> @graphviz.Digraph
fn NFAT::to_json(Self) -> Json // from trait `ToJson`
fn NFAT::to_string(Self) -> String // from trait `Show`
impl Eq for NFAT
impl Show for NFAT
impl ToJson for NFAT

pub struct RDFA {
  initial : NFAS
  finals : @set.Set[NFAS]
  dfat : RDFAT
  alphabet_count : Int
}
fn RDFA::output(Self, &Logger) -> Unit // from trait `Show`
fn RDFA::to_dfa(Self) -> DFA
fn RDFA::to_digraph(Self, symbol_to_letter~ : (Int) -> Char) -> @graphviz.Digraph
fn RDFA::to_json(Self) -> Json // from trait `ToJson`
fn RDFA::to_string(Self) -> String // from trait `Show`
impl Show for RDFA
impl ToJson for RDFA

type RDFAT
fn RDFAT::contains(Self, NFAS) -> Bool
fn RDFAT::equal(Self, Self) -> Bool // from trait `Eq`
fn RDFAT::iter2(Self) -> Iter2[NFAS, Map[Int, NFAS]]
fn RDFAT::keys(Self) -> Iter[NFAS]
fn RDFAT::length(Self) -> Int
#deprecated
fn RDFAT::op_equal(Self, Self) -> Bool // from trait `Eq`
fn RDFAT::op_get(Self, NFAS) -> Map[Int, NFAS]
fn RDFAT::op_set(Self, NFAS, Map[Int, NFAS]) -> Unit
fn RDFAT::output(Self, &Logger) -> Unit // from trait `Show`
fn RDFAT::to_json(Self) -> Json // from trait `ToJson`
fn RDFAT::to_string(Self) -> String // from trait `Show`
fn RDFAT::update(Self, NFAS, (Map[Int, NFAS]?) -> Map[Int, NFAS]?) -> Unit
impl Eq for RDFAT
impl Show for RDFAT
impl ToJson for RDFAT

pub(all) enum RNFA {
  Symbol(initial~ : Int, Int, final_~ : Int)
  Concat(RNFA, RNFA)
  Choice(initial~ : Int, RNFA, RNFA, final_~ : Int)
  Repeat(initial~ : Int, RNFA, final_~ : Int)
}
fn RNFA::compare(Self, Self) -> Int // from trait `Compare`
fn RNFA::equal(Self, Self) -> Bool // from trait `Eq`
#deprecated
fn RNFA::op_equal(Self, Self) -> Bool // from trait `Eq`
fn RNFA::output(Self, &Logger) -> Unit // from trait `Show`
fn RNFA::to_digraph(Self, symbol_to_letter~ : (Int) -> Char) -> @graphviz.Digraph
fn RNFA::to_json(Self) -> Json // from trait `ToJson`
fn RNFA::to_string(Self) -> String // from trait `Show`
impl Compare for RNFA
impl Eq for RNFA
impl Show for RNFA
impl ToJson for RNFA

pub(all) enum Regex {
  Concat(Regex, Regex)
  Choice(Regex, Regex)
  Repeat(Regex)
  Symbol(Int)
}
fn Regex::compare(Self, Self) -> Int // from trait `Compare`
fn Regex::equal(Self, Self) -> Bool // from trait `Eq`
#deprecated
fn Regex::op_equal(Self, Self) -> Bool // from trait `Eq`
fn Regex::output(Self, &Logger) -> Unit // from trait `Show`
fn Regex::to_json(Self) -> Json // from trait `ToJson`
fn Regex::to_nfa(Self, initial~ : Int, alphabet_count~ : Int) -> NFA
fn Regex::to_nfac(Self, initial~ : Int) -> NFAC
fn Regex::to_string(Self) -> String // from trait `Show`
impl Compare for Regex
impl Eq for Regex
impl Show for Regex
impl ToJson for Regex

// Type aliases

// Traits

